<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Marcos Longo" />


<title>FATES assessment script</title>

<script src="site_libs/header-attrs-2.8/header-attrs.js"></script>
<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/darkly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>





<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">FATES Utilities</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="make_fates_met_driver.html">Meteorological driver</a>
</li>
<li>
  <a href="make_fates_domain+surface.html">Surface/Domain files</a>
</li>
<li>
  <a href="create_case_hlm-fates.html">Set up single-site runs</a>
</li>
<li>
  <a href="fates_plot_monthly.html">Single-site visualisation with R</a>
</li>
<li>
  <a href="make_fates_tower_summary.html">Make tower-based benchmark file</a>
</li>
<li>
  <a href="fates_tower_compare_monthly.html">Evaluate FATES against tower</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">FATES assessment script</h1>
<h4 class="author">Marcos Longo</h4>
<h4 class="date">15-Jul-2021</h4>

</div>


<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This R Markdown document guides how to build a set of output figures and metrics to evaluate FATES simulations at a single site, using monthly averages. The script is (permanently?) under development, and new features may be incorporated over time.</p>
<p>To run this script, you will need to have FATES simulations, a netCDF file with monthly averages generated by the <a href="https://github.com/mpaiao/FATES_Utils/blob/master/make_fates_tower_summary.Rmd">make_fates_tower_summary.Rmd</a> script, and a few additional scripts (typically located at the <code>&lt;path to&gt;/RUtils</code> directory (download the entire directory from <a href="https://github.com/mpaiao/FATES_Utils">GitHub</a>). Most scripts are generic utilities, but if you are adding new comparison variables, you may want to check and edit the <strong>hlm_varlist.r</strong> script (comments in this script provide additional details).</p>
</div>
<div id="reset-session" class="section level1">
<h1>Reset session</h1>
<p>Use this chunk to fully reset R.</p>
<pre class="r"><code># Unload all packages except for the R default ones
plist = names(sessionInfo()$otherPkgs)
if (length(plist) &gt; 0){
   dummy = sapply(X=paste0(&quot;package:&quot;,plist),FUN=detach,character.only=TRUE,unload=TRUE)
}#end if (length(plist) &gt; 0)


# Remove all variables
rm(list=ls())

# Reset warnings
options(warn=0)

# Close all plots
invisible(graphics.off())

# Clean up
invisible(gc())</code></pre>
</div>
<div id="initial-settings" class="section level1">
<h1>Initial settings</h1>
<p>In this part, we set a few useful global paths, files, and variables.</p>
<p>First, we define the case:</p>
<ul>
<li><strong>case_name</strong>. The case name. This should be typically the name of the case sub-directory to where the simulation output files were written. This will be used together with <code>hesm_main</code> (see below) to define the full path.</li>
<li><strong>case_desc</strong>. The case description. Not a path, but useful for plot titles (put here so it’s easy to remember to update).</li>
<li><strong>case_model</strong>. Name of the land model, which will be used for legends.</li>
</ul>
<pre class="r"><code>case_name  = &quot;D0005_ParacouTest_CLM_FATES&quot;
case_desc  = &quot;D0005: Paracou test (CLM-FATES)&quot;
case_model = &quot;CLM-FATES&quot;</code></pre>
<p>We then set some global paths: * <strong>home_path</strong>. Typically the user’s home path. Useful for building other paths. <code>path.expand("~")</code> typically works for all users. * <strong>hesm_main</strong>. The main directory to where all simulation results are written. The script will assume that the main path for this case simulation <code>case_path=file.path(hesm_main,case_name)</code>. * <strong>site_main</strong>. The main path where the individual site files are located (excluding the sub-directory for the specific site). * <strong>util_path</strong>. The path with the additional utility scripts (the full path of <code>RUtils</code>). * <strong>plot_main</strong>. The main path to where to save figures. The following sub-directories will be created: - <em>comp_tseries_path</em>. Where tower vs. FATES time series will be saved. - <em>comp_monmean_path</em>. Where tower vs. FATES mean annual cycle will be saved. - <em>taylor_biasvar_path</em>. Where Taylor diagrams and bias-variance diagrams will be saved.</p>
<pre class="r"><code>home_path  = path.expand(&quot;~&quot;)
hesm_main  = file.path(home_path,&quot;Documents/LocalData/FATES/Simulations&quot;)
site_main  = file.path(home_path,&quot;Data/FATES_DataSets&quot;)
util_path  = file.path(home_path,&quot;Util/RUtils&quot;)
plot_main  = file.path(hesm_main,&quot;figures&quot;,case_name)</code></pre>
<p>Set the name of the sub-directory in <code>site_main</code> containing the tower averages by month and year for this particular site. This uses the structure created by the <a href="https://github.com/mpaiao/FATES_Utils">FATES Utilities</a> tools.</p>
<pre class="r"><code>site_name = &quot;1x1pt-paracouGUF_v1.5_c20210713&quot;</code></pre>
<p>Set maximum time range to be included in the plots.</p>
<pre class="r"><code>tstampa = &quot;01/01/2004&quot; # First time (MM/DD/YYYY)
tstampz = &quot;12/01/2019&quot; # Last time (MM/DD/YYYY)</code></pre>
<p>Settings for time series comparisons. These control the colours and transparency levels for site measurements/estimates and model predictions.</p>
<pre class="r"><code># Set colours for site measurements/estimates and model predictions.
site_colour = &quot;#000000&quot;
hlm_colour  = &quot;#1B9E77&quot;

# Define lower and upper bound for interannual variability ribbon around the mean.
sdev_ribbon  = 1.                  # Standard-deviation equivalent for ribbon 
qlwr_ribbon  = pnorm(-sdev_ribbon) # Lower quantile for ribbon
qupr_ribbon  = pnorm(+sdev_ribbon) # Lower quantile for ribbon
alpha_ribbon = 0.4                 # Transparency for ribbon</code></pre>
<p>General plot options for <code>ggplot</code></p>
<pre class="r"><code>gg_device  = c(&quot;pdf&quot;) # Output devices to use (Check ggsave for acceptable formats)
gg_depth   = 300      # Plot resolution (dpi)
gg_ptsz    = 15       # Font size
gg_width   = 11.0     # Plot width (units below)
gg_height  = 8.5      # Plot height (units below)
gg_units   = &quot;in&quot;     # Units for plot size
gg_screen  = TRUE     # Show plots on screen as well?
gg_tfmt    = &quot;%Y&quot;     # Format for time 

ndevice = length(gg_device)</code></pre>
</div>
<div id="main-script" class="section level1">
<h1>Main script</h1>
<p><strong>Note:</strong> Changes beyond this point are only needed if you are developing the notebook.</p>
<div id="initial-settings." class="section level2">
<h2>Initial settings.</h2>
<p>First, we load the list of host land model variables that we may consider for the comparison. We also load <code>list.2.data.table.r</code> to</p>
<pre class="r"><code>source(file.path(util_path,&quot;load.everything.r&quot;),chdir=TRUE)</code></pre>
<pre><code>##  + Load scripts from /Users/marcoslongo/Dropbox/Home/Util/RUtils.</code></pre>
<p>We then make sure to set up the derived paths and files.</p>
<pre class="r"><code># Case path.  Do not change this unless you used non-standard case output for ELM/CLM.
case_path = file.path(hesm_main,case_name)

#---~---
#    Vector with all possible ELM/CLM paths containing NetCDF history files.  Do not change
# this unless you know what you are doing.
#---~---
simul_path = c( file.path(case_path,&quot;run&quot;), file.path(case_path,&quot;lnd&quot;,&quot;hist&quot;))


# Output path for time series.
comparison_path     = file.path(plot_main,&quot;comparison&quot;    )
taylor_biasvar_path = file.path(plot_main,&quot;taylor_biasvar&quot;)

# Create output paths.
dummy = dir.create(comparison_path    ,recursive = TRUE,showWarnings = FALSE)
dummy = dir.create(taylor_biasvar_path,recursive = TRUE,showWarnings = FALSE)

# Define eddy covariance tower file
site_path = file.path(site_main,site_name)
site_base = list.files(path=site_path,pattern=&quot;_eddy-summ\\.nc$&quot;)

#    Make sure we found the tower file, otherwise, stop. In case more than one file exists, 
# we take the most recent one. 
if (length(site_base) &gt; 0){
   site_file = file.path(site_path,site_base)
   site_info = file.info(site_file)
   iuse      = which.max(as.POSIXct(site_info$mtime))
   site_base = site_base[iuse]
   site_file = site_file[iuse]
}else{
   cat(&quot; Tower file data not found.  Check your settings.\n&quot;)
   cat(&quot; site_main = \&quot;&quot;,site_main,&quot;\&quot;\n&quot;,sep=&quot;&quot;)
   cat(&quot; site_name = \&quot;&quot;,site_name,&quot;\&quot;\n&quot;,sep=&quot;&quot;)
   cat(&quot; site_path = \&quot;&quot;,site_path,&quot;\&quot;\n&quot;,sep=&quot;&quot;)
   cat(&quot; Path \&quot;site_main\&quot; exists = &quot;,file.exists(site_main),&quot;\n&quot;,sep=&quot;&quot;)
   cat(&quot; Path \&quot;site_path\&quot; exists = &quot;,file.exists(site_path),&quot;\n&quot;,sep=&quot;&quot;)
   stop(&quot; Path settings for site data are likely incorrect.&quot;)
}</code></pre>
<p>Define times to consider.</p>
<pre class="r"><code># Extract date information from string
if (is.character(tstampa)){
   tstampa = as.integer(unlist(strsplit(tstampa,split=&quot;/&quot;)))
   yeara   = tstampa[3]
   montha  = tstampa[1]
}#end if (is.character(tstampa))
if (is.character(tstampz)){
   tstampz = as.integer(unlist(strsplit(tstampz,split=&quot;/&quot;)))
   yearz   = tstampz[3]
   monthz  = tstampz[1]
}#end if (is.character(tstampz))

# Useful variables to build time stamps.
nmontha   = 12 - montha + 1          # Number of months in yeara
nmidyears = max(0,yearz - yeara - 1) # Number of years in between yeara and yearz
nmonthz   = monthz                   # Number of months in yearz

# Create lubridate object for initial and final time
tstampa = make_datetime( year=yeara,month=montha,day=1L)
tstampz = make_datetime( year=yearz,month=monthz,day=1L)

# Create month and year vector
if (yeara == yearz){
   # Simulation did not last more than one year
   tmonth = seq(from=montha,to=monthz,by=1)
   tyear  = rep(x=yeara,times=length(tmonth))
}else{
   # Simulation lasted longer than a year.
   tmonth = c( seq(from=montha,to=12,by=1)
             , rep(sequence(12),times=nmidyears)
             , seq(from=1     ,to=monthz,by=1)
             )#end c
   tyear  = c( rep(yeara,each=nmontha)
             , rep(yeara+sequence(nmidyears),each=12)
             , rep(yearz,each=nmonthz)
             )#end c
}#end if (yeara == yearz)

# Create time stamp and find how many times should be processed.
tstamp = make_datetime(year=tyear,month=tmonth,day=1L)
ntstamp = length(tstamp)</code></pre>
</div>
<div id="data-retrieval." class="section level2">
<h2>Data retrieval.</h2>
<p>First we retrieve the site measurements and estimates of ecosystem productivity and respiration. Currently we only load simple time series, but in the future we may also consider canopy layer and soil measurements. Here we perform the following tasks:</p>
<ol style="list-style-type: decimal">
<li>Load variables to be compared with the model.</li>
<li>Apply unit conversion factors.</li>
<li>Organise the data into a <code>tibble</code> object.</li>
</ol>
<p>For additional information on which variables to be loaded and which units to use in the output, check the <code>hlm1dvar</code> settings in <a href="https://github.com/mpaiao/FATES_Utils/blob/master/RUtils/hlm_varlist.r">RUtils/hlm_varlist.r</a>.</p>
<pre class="r"><code>if (&quot;nc_site&quot; %in% ls()){dummy = nc_close(nc_site); rm(nc_site)}

# Open NetCDF connection and retrieve variable names
cat0(&quot; + Load site data from &quot;,site_base,&quot;.&quot;)</code></pre>
<pre><code>##  + Load site data from 1x1pt-paracouGUF_v1.5_c20210713_eddy-summ.nc.</code></pre>
<pre class="r"><code>nc_site  = nc_open(filename=site_file)
nc_nvars = nc_site$nvars
nc_ndims = nc_site$ndims
nc_dlist = rep(NA_character_,times=nc_ndims)
nc_vlist = rep(NA_character_,times=nc_nvars)
for (d in sequence(nc_ndims)) nc_dlist[d] = nc_site$dim[[d]]$name
for (v in sequence(nc_nvars)) nc_vlist[v] = nc_site$var[[v]]$name

# Select variables to load
nc_obs1d    = nc_vlist[tolower(nc_vlist) %in% hlm1dvar$vnam[hlm1dvar$assess]]


# Extract time information
site_time0  = as_datetime(gsub(pattern=&quot;^days since &quot;,replacement=&quot;&quot;,x=nc_site$dim$time$units))
site_time   = site_time0 + days(nc_site$dim$time$vals)
n_site_time = nc_site$dim$time$len

# Initialise a tibble that will host all data
site1d = tibble( time = site_time)

# Find conversion factors for monthly variables.
cmon.day = days_in_month(site1d$time)
cmon.hr  = day.hr  * cmon.day
cmon.min = day.min * cmon.day
cmon.sec = day.sec * cmon.day

# Loop through variables, and load data sets.
for (o in seq_along(nc_obs1d)){
   # Retrieve settings for variable
   nc_nvnow        = nc_obs1d[o]
   h               = match(tolower(nc_nvnow),hlm1dvar$vnam)
   h_vnam          = hlm1dvar$vnam[h]
   h_desc          = hlm1dvar$desc[h]
   h_add0          = eval(parse(text=hlm1dvar$add0[h]))
   h_mult          = eval(parse(text=hlm1dvar$mult[h]))
   nc_dat          = ncvar_get(nc=nc_site,varid=nc_nvnow)
   cat0(&quot;   - Retrieve &quot;,h_desc,&quot;.&quot;)
   site1d[[h_vnam]] = h_add0 + h_mult * nc_dat
}#end for (o in seq_along(nc_obs1d))</code></pre>
<pre><code>##    - Retrieve Upward shortwave radiation.
##    - Retrieve Upward longwave radiation.
##    - Retrieve Sensible heat flux.
##    - Retrieve Total evaporation.
##    - Retrieve Friction velocity.
##    - Retrieve Gross primary productivity.
##    - Retrieve Ecosystem respiration.
##    - Retrieve Net ecosystem productivity.</code></pre>
<pre class="r"><code># Load site coordinates. We will check whether observations and model are reasonably close.
site_coord = tibble( clon = c(ncvar_get(nc=nc_site,varid=&quot;LONGXY&quot;))
                   , clat = c(ncvar_get(nc=nc_site,varid=&quot;LATIXY&quot;))
                   , wlon = c(ncvar_get(nc=nc_site,varid=&quot;EDGEW&quot; ))
                   , elon = c(ncvar_get(nc=nc_site,varid=&quot;EDGEE&quot; ))
                   , slat = c(ncvar_get(nc=nc_site,varid=&quot;EDGES&quot; ))
                   , nlat = c(ncvar_get(nc=nc_site,varid=&quot;EDGEN&quot; ))
                   )#end tibble


# Close file and remove connection.
dummy = nc_close(nc_site)
rm(nc_site)</code></pre>
<p>The time span for site measurements and tower may not match. In this case, we identify the overlapping time interval, and trim both the site and model assessment to this period in which both are available. We always keep track of the actual first time of the model, though, because the first history file contains additional data that may be useful when we adapt the code to compare soil state variables.</p>
<pre class="r"><code># Save the original time stamp for the first model time, so we retrieve useful dimensions
tstamp0 = tstampa

# Find the minimum interval that has overlaps with both site and model.
tstampa = max(c(min(tstamp),min(site1d$time)))
tstampz = min(c(max(tstamp),max(site1d$time)))

# Restrict time to the overlapping period
tstamp  = tstamp[(tstamp &gt;= tstampa) &amp; (tstamp &lt;= tstampz)]
ntstamp = length(tstamp)

#   Trim site observations to the overlapping period. Also, standardise the data so we
# use only one of NA or NaN.
site1d = site1d %&gt;%
         filter( (time &gt;= tstampa) &amp; (time &lt;= tstampz)) %&gt;%
         mutate_at(vars(-time),function(x) ifelse(is.nan(x),NA,x))</code></pre>
<p>Here we perform the following tasks, using the actual first history file from the ELM/CLM simulation:</p>
<ul>
<li>Determine which path and file name structure .</li>
<li>Initialise a <code>tibble</code> object for all the candidate variables (Check <code>hlm1dvar</code> settings in <a href="https://github.com/mpaiao/FATES_Utils/blob/master/RUtils/hlm_varlist.r">RUtils/hlm_varlist.r</a> for the list of variables).</li>
<li>Retrieve soil information (which will be useful when comparing the model against soil measurements).</li>
<li>Retrieve size and PFT indices for the <code>_SCPF</code> variables (which will be useful in the future for comparing the model against census measurements).</li>
</ul>
<pre class="r"><code>if (&quot;nc_zero&quot; %in% ls()){dummy = nc_close(nc_zero); rm(nc_zero)}


#---~---
# Determine which path and base to use.
#---~---
cat0(&quot; + Guess path and model from settings.&quot;)</code></pre>
<pre><code>##  + Guess path and model from settings.</code></pre>
<pre class="r"><code># Extract times and build all possible file names
w_month    = month(tstamp0)
w_year     = year (tstamp0)
w_ymlab    = sprintf(&quot;%4.4i-%2.2i&quot;,w_year,w_month)
hlm_midfix = c(&quot;elm.h0&quot;,&quot;clm2.h0&quot;)
nc_base    = paste0(case_name,&quot;.&quot;,hlm_midfix,&quot;.&quot; ,w_ymlab,&quot;.nc&quot;)
nc_file    = file.path( rep(x = simul_path, times = length(nc_base   ))
                      , rep(x = nc_base   , each  = length(simul_path))
                      )#end file.path

# Identify which model and path to use.
idx = which(file.exists(nc_file))
if (length(idx) &gt; 0){
   # Load the correct file.
   nc_file = (nc_file[idx])[1]
   nc_base = basename(nc_file)

   # Remember which path and model to use for other times
   simul_path = dirname(nc_file)
   sel_midfix = mapply(FUN=grepl,pattern=as.list(hlm_midfix),MoreArgs=list(x=nc_base))
   hlm_midfix = hlm_midfix[sel_midfix]
}else{
   # No file was found. Stop the run
   cat0(&quot; + Neither CLM nor ELM expected files found.&quot;)
   cat0(&quot;   - Expected ELM file:    &quot;,nc_file[1],&quot;.&quot;)
   cat0(&quot;   - Expected CLM file:    &quot;,nc_file[4],&quot;.&quot;)
   cat0(&quot;   - Alternative ELM file: &quot;,nc_file[2],&quot;.&quot;)
   cat0(&quot;   - Alternative CLM file: &quot;,nc_file[3],&quot;.&quot;)
   stop(&quot; Invalid files, perhaps incorrect simulation?&quot;)
}#end if (length(idx) &gt; 0)

  
# Open NetCDF connection and retrieve variable names
cat0(&quot; + Load initial data settings from &quot;,nc_base,&quot;.&quot;)</code></pre>
<pre><code>##  + Load initial data settings from D0005_ParacouTest_CLM_FATES.clm2.h0.2004-01.nc.</code></pre>
<pre class="r"><code>nc_zero  = nc_open(filename=nc_file)
nc_nvars = nc_zero$nvars
nc_ndims = nc_zero$ndims
nc_dlist = rep(NA_character_,times=nc_ndims)
nc_vlist = rep(NA_character_,times=nc_nvars)
for (d in sequence(nc_ndims)) nc_dlist[d] = nc_zero$dim[[d]]$name
for (v in sequence(nc_nvars)) nc_vlist[v] = nc_zero$var[[v]]$name

#---~---
# Gather variable information, then initialise tibble
#---~---

cat0(&quot;   - Identify all HLM variables.&quot;)</code></pre>
<pre><code>##    - Identify all HLM variables.</code></pre>
<pre class="r"><code># Retrieve all &quot;1D&quot; variables that are available at the host model.
nc_pref   = tolower(x=nc_vlist)
nc_keep   = nc_pref %in% hlm1dvar$vnam
no_hlm1d  = nc_vlist[! nc_keep]
nc_hlm1d  = nc_vlist[  nc_keep]

# Check whether to append &quot;evapotranspiration&quot;
cat(&quot;   - Check whether or not we can find evapotranspiration... &quot;)</code></pre>
<pre><code>##    - Check whether or not we can find evapotranspiration...</code></pre>
<pre class="r"><code>if (  ( all(c(&quot;QSOIL&quot;,&quot;QVEGT&quot;,&quot;QVEGE&quot;) %in% nc_hlm1d) ) &amp;&amp; (! &quot;QEVTR&quot; %in% nc_hlm1d) ){
   nc_hlm1d = unique(c(nc_hlm1d,&quot;QEVTR&quot;))
   etr_last = TRUE
   cat0(&quot;  Yes!&quot;)
}else{
   etr_last = FALSE
   cat0(&quot;  No!&quot;)
}#end if (  ( all(c(&quot;QSOIL&quot;,&quot;QVEGT&quot;,&quot;QVEGE&quot;) %in% nc_hlm1d) ) &amp;&amp; (! &quot;QEVTR&quot; %in% nc_hlm1d) )</code></pre>
<pre><code>##   Yes!</code></pre>
<pre class="r"><code># Check whether to append ecosystem respiration
cat(&quot;   - Check whether or not we can find ecosystem respiration... &quot;)</code></pre>
<pre><code>##    - Check whether or not we can find ecosystem respiration...</code></pre>
<pre class="r"><code>if (  ( all(c(&quot;AR&quot;,&quot;HR&quot;) %in% nc_hlm1d) ) &amp;&amp; (! &quot;ER&quot; %in% nc_hlm1d) ){
   nc_hlm1d = unique(c(nc_hlm1d,&quot;ER&quot;))
   er_last  = TRUE
   cat0(&quot;  Yes!&quot;)
}else{
   er_last  = FALSE
   cat0(&quot;  No!&quot;)
}#end if (  ( all(c(&quot;AR&quot;,&quot;HR&quot;) %in% nc_hlm1d) ) &amp;&amp; (! &quot;ER&quot; %in% nc_hlm1d) )</code></pre>
<pre><code>##   Yes!</code></pre>
<pre class="r"><code># Find number of host land model variables
nhlm1d    = length(nc_hlm1d)


# Initialise 1D variables available at the HLM
cat0(&quot;   - Initialise tibble for the host land model.&quot;)</code></pre>
<pre><code>##    - Initialise tibble for the host land model.</code></pre>
<pre class="r"><code>hlm1d = tibble(time = tstamp)
for (h in seq_along(nc_hlm1d)){
   h_vnam          = tolower(nc_hlm1d[h])
   hlm1d[[h_vnam]] = rep(NA,times=ntstamp)
}#end for (h in seq_along(nc_hlm1d))


# Load simulation coordinates. We check whether observations and model are reasonably close.
hlm1d_coord = tibble( clon = c(ncvar_get(nc=nc_zero,varid=&quot;lon&quot;))
                    , clat = c(ncvar_get(nc=nc_zero,varid=&quot;lat&quot;))
                    )#end tibble
lon_fine = hlm1d_coord$clon &gt;= site_coord$wlon &amp;&amp; hlm1d_coord$clon &lt;= site_coord$elon
lat_fine = hlm1d_coord$clat &gt;= site_coord$slat &amp;&amp; hlm1d_coord$clat &lt;= site_coord$nlat
if (! all(c(lon_fine,lat_fine))){
   cat0(&quot;------------------------------------------------------------------&quot;)
   cat0(&quot; Simulation and site information are not from the same location.  &quot;)
   cat0(&quot; &quot;)
   cat0(&quot; Site&quot;)
   cat0(&quot; Longitude:               &quot;,site_coord$clon)
   cat0(&quot; Latitude:                &quot;,site_coord$clat)
   cat0(&quot; Zonal grid extent:      (&quot;,site_coord$wlon,&quot;;&quot;,site_coord$elon,&quot;)&quot;)
   cat0(&quot; Meridional grid extent: (&quot;,site_coord$slat,&quot;;&quot;,site_coord$nlat,&quot;)&quot;)
   cat0(&quot; &quot;)
   cat0(&quot; Model&quot;)
   cat0(&quot; Longitude:               &quot;,hlm1d_coord$clon)
   cat0(&quot; Latitude:                &quot;,hlm1d_coord$clat)
   cat0(&quot;------------------------------------------------------------------&quot;)
   stop(&quot; Model coordinates must be within the site grid extent.&quot;)
}#end if (! all(c(lon_fine,lat_fine)))



# Load soil layers.  This is currently not used, but could be used for soil comparisons.
cat0(&quot;   - Load soil information&quot;)</code></pre>
<pre><code>##    - Load soil information</code></pre>
<pre class="r"><code>slayer = tibble( zsoi   = c(unlist(ncvar_get(nc=nc_zero,varid=&#39;ZSOI&#39;  )))
               , dzsoi  = c(unlist(ncvar_get(nc=nc_zero,varid=&#39;DZSOI&#39; )))
               , bsw    = c(unlist(ncvar_get(nc=nc_zero,varid=&#39;BSW&#39;   )))
               , hksat  = c(unlist(ncvar_get(nc=nc_zero,varid=&#39;HKSAT&#39; )))
               , sucsat = c(unlist(ncvar_get(nc=nc_zero,varid=&#39;SUCSAT&#39;)))
               , watsat = c(unlist(ncvar_get(nc=nc_zero,varid=&#39;WATSAT&#39;)))
               )#end data.table

#---~---
#    Load size and PFT indices. This is currently not used, but could be used for 
# census comparisons.
#---~---
cat0(&quot;   - Load indices for size- and pft-dependent variables.&quot;)</code></pre>
<pre><code>##    - Load indices for size- and pft-dependent variables.</code></pre>
<pre class="r"><code>index_scpf = tibble( scls   = ncvar_get(nc=nc_zero,varid=&#39;fates_scmap_levscpf&#39;  )
                   , pft    = ncvar_get(nc=nc_zero,varid=&#39;fates_pftmap_levscpf&#39; )
                   )#end data.table

# Close connection
dummy   = nc_close(nc_zero)</code></pre>
<p>We now go through every monthly output file to retrieve the averages by month and year. Specifically, we do the following: 1. Load all the 1-D variables available in the history file and defined in the <code>hlm1dvar</code> object (see <a href="https://github.com/mpaiao/FATES_Utils/blob/master/RUtils/hlm_varlist.r">RUtils/hlm_varlist.r</a>). 2. Apply unit conversion factors. 3. Find derived variables that are not directly available in the history files (currently evapotranspiration and ecosystem respiration). 4. Organise the data into a <code>tibble</code> object.</p>
<pre class="r"><code>cat0(&quot; + Load model output.&quot;)
if (&quot;nc_hlm&quot; %in% ls()){dummy = nc_close(nc_hlm); rm(nc_hlm)}
for (w in sequence(ntstamp)){
   # Extract times and build file name
   w_month  = month(tstamp[w])
   w_year   = year (tstamp[w])
   w_ymlab  = sprintf(&quot;%4.4i-%2.2i&quot;,w_year,w_month)
   nc_base  = paste0(case_name,&quot;.&quot;,hlm_midfix,&quot;.&quot; ,w_ymlab,&quot;.nc&quot;)
   nc_file  = file.path(simul_path,nc_base)
   cat0(&quot;   - Retrieve file &quot;,nc_base,&quot;.&quot;)

   
   # Find conversion factors for monthly variables.
   cmon.day = days_in_month(tstamp[w])
   cmon.hr  = day.hr  * cmon.day
   cmon.min = day.min * cmon.day
   cmon.sec = day.sec * cmon.day

  
   # Open NetCDF connection and retrieve variable names
   nc_hlm   = nc_open(filename=nc_file)

   # Read 1D variables  
   for (v in sequence(nhlm1d-etr_last-er_last)){
      nc_nvnow            = nc_hlm1d[v]
      nc_pref             = tolower(x=nc_nvnow)
      h                   = match(nc_pref,hlm1dvar$vnam)
      h_vnam              = hlm1dvar$vnam[h]
      h_add0              = eval(parse(text=hlm1dvar$add0[h]))
      h_mult              = eval(parse(text=hlm1dvar$mult[h]))
      nc_dat              = ncvar_get(nc=nc_hlm,varid=nc_nvnow)
      hlm1d[[h_vnam]][w]  = h_add0 + h_mult * nc_dat
   }#for (h in sequence(nhlm1d-etr_last-et_last))

   # Find total ET.
   if (etr_last){
      hlm1d$qevtr[w] = hlm1d$qvege[w] + hlm1d$qvegt[w] + hlm1d$qsoil[w]
   }#end if (etr_last)

   # Find total ET.
   if (er_last){
      hlm1d$er[w] = hlm1d$ar[w] + hlm1d$hr[w]
   }#end if (er_last)

   # Close connection
   dummy   = nc_close(nc_hlm)
}#end for (w in sequence(nstamp))</code></pre>
<p>We now compare the variables from the site measurements and the model, and keep only the variables present in both data sets.</p>
<pre class="r"><code>cat0(&quot; + Find the variables common to both site and model.&quot;)</code></pre>
<pre><code>##  + Find the variables common to both site and model.</code></pre>
<pre class="r"><code># Find common variables
var_both = intersect(names(site1d),names(hlm1d))
var_both = var_both[! var_both %in% &quot;time&quot;]

# Restrict variables for both site and model
site1d = site1d %&gt;% select( all_of(c(&quot;time&quot;,var_both)))
hlm1d  = hlm1d  %&gt;% select( all_of(c(&quot;time&quot;,var_both)))</code></pre>
<p>Combine site and model into a single object (<code>emean</code>), then we calculate mean seasonality and the range (<code>mmean</code>).</p>
<pre class="r"><code># Merge data sets, we set 1 for site measurements, and 2 for the host model.
cat0(&quot; + Merge data sets into a single tibble.&quot;)</code></pre>
<pre><code>##  + Merge data sets into a single tibble.</code></pre>
<pre class="r"><code>emean  = rbind( site1d %&gt;% mutate(source = 0L)
              , hlm1d  %&gt;% mutate(source = 1L) ) %&gt;%
         select(all_of(c(&quot;time&quot;,&quot;source&quot;,var_both)))

# Find the mean seasonal cycle.
mmean = emean                                                             %&gt;%
        mutate( year = year(time), month = month(time))                   %&gt;%
        group_by(month,source)                                            %&gt;%
        select(! c(time,year))                                            %&gt;%
        summarise_all(mean, na.rm=TRUE)                                   %&gt;%
        ungroup()                                                         %&gt;%
        rename_at(vars(var_both), function(x) paste0(x,&quot;_mean&quot;))</code></pre>
<pre><code>## Note: Using an external vector in selections is ambiguous.
## ℹ Use `all_of(var_both)` instead of `var_both` to silence this message.
## ℹ See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.
## This message is displayed once per session.</code></pre>
<pre class="r"><code># Find the lower range of the seasonal cycle
mqlwr = emean                                                             %&gt;%
        mutate( year = year(time), month = month(time))                   %&gt;%
        group_by(month,source)                                            %&gt;%
        select(! c(time,year))                                            %&gt;%
        summarise_all(quantile,probs=qlwr_ribbon,names=FALSE, na.rm=TRUE) %&gt;%
        ungroup()                                                         %&gt;%
        rename_at(vars(var_both), function(x) paste0(x,&quot;_qlwr&quot;))

# Find the upper range of the seasonal cycle
mqupr = emean                                                             %&gt;%
        mutate( year = year(time), month = month(time))                   %&gt;%
        group_by(month,source)                                            %&gt;%
        select(! c(time,year))                                            %&gt;%
        summarise_all(quantile,probs=qupr_ribbon,names=FALSE, na.rm=TRUE) %&gt;%
        ungroup()                                                         %&gt;%
        rename_at(vars(var_both), function(x) paste0(x,&quot;_qupr&quot;))

# Find the annual averages.
mmean = as_tibble( merge( x  = merge(x=mmean,y=mqlwr,by=c(&quot;month&quot;,&quot;source&quot;))
                        , y  = mqupr
                        , by = c(&quot;month&quot;,&quot;source&quot;)
                        )#end merge
                 )#end as_tibble

# Sort data by month and source
mmean = mmean %&gt;% arrange(source,month)</code></pre>
</div>
<div id="simple-model-evaluation-plots" class="section level2">
<h2>Simple model evaluation plots</h2>
<p>First, we plot the time series of monthly averages for both site measurements (or estimates) and model predictions.</p>
<pre class="r"><code>cat0(&quot; + Plot time series comparisons between site measurements/estimates and model predictions.&quot;)


# Set legends
leg_colours = c(site_colour,hlm_colour)
leg_labels  = c(&quot;Site&quot;,case_model)

gg_emean = list()
for (v in seq_along(var_both)){
   # Load variable
   h        = match(var_both[v],hlm1dvar$vnam)
   h_vnam   = hlm1dvar$vnam [h]
   h_desc   = hlm1dvar$desc [h]
   h_short  = hlm1dvar$short[h]
   h_unit   = hlm1dvar$unit [h]
   h_legend = v == 1 


   # Temporary data table. We convert the classes back to factor.
   h_emean        = emean
   h_emean$source = factor(h_emean$source,levels=unique(h_emean$source))

   # Initialise plot (we use line)
   gg_now = ggplot(data=h_emean,aes_string(x=&quot;time&quot;,y=h_vnam,group=&quot;source&quot;,colour=&quot;source&quot;))
   gg_now = gg_now + scale_colour_manual(name=&quot;&quot;,labels=leg_labels,values=leg_colours)

   # We only add legend for a single plot.  Patchwork will fix this in the end.
   gg_now = gg_now + geom_line(lwd=0.8,show.legend = h_legend)
  
   # Add local annotation
   gg_now = gg_now + labs(title=element_blank())
   gg_now = gg_now + scale_x_datetime(date_labels=gg_tfmt)
   gg_now = gg_now + xlab(element_blank())
   gg_now = gg_now + ylab(desc.unit(desc=h_short,unit=untab[[h_unit]],dxpr=TRUE))
   gg_now = gg_now + theme_grey( base_size      = gg_ptsz
                               , base_family    = &quot;Helvetica&quot;
                               , base_line_size = 0.5
                               , base_rect_size = 0.5
                               )#end theme_grey

   # Additional legend settings
   # if (h_legend) gg_now = gg_now + theme( legend.position = &quot;bottom&quot;)

   # Axis settings
   gg_now = gg_now + theme( axis.text.x       = element_text( size   = gg_ptsz
                                                            , margin = unit(rep(0.35,times=4),&quot;char&quot;)
                                                            )#end element_text
                          , axis.text.y       = element_text( size   = gg_ptsz
                                                            , margin = unit(rep(0.35,times=4),&quot;char&quot;)
                                                            )#end element_text
                          , axis.ticks.length = unit(-0.2,&quot;char&quot;)
                          , axis.title.y      = element_text( size = gg_ptsz * 0.9)
                          )#end theme

  # Write plot settings to the list.
  gg_emean[[h_vnam]] = gg_now
}#end for (v in seq_along(var_both)){

# Wrap plots then global settings and x axis.
gg_patch = wrap_plots(gg_emean)
gg_patch = gg_patch + guide_area() + plot_layout(guides=&quot;collect&quot;)
gg_patch = gg_patch + plot_annotation(tag_levels = &quot;a&quot;, title = case_desc)

# Save plots.
for (d in sequence(ndevice)){
   h_output = paste0(&quot;comparison_tseries-&quot;,case_name,&quot;.&quot;,gg_device[d])
   dummy    = ggsave( filename = h_output
                    , plot     = gg_patch
                    , device   = gg_device[d]
                    , path     = comparison_path
                    , width    = gg_width
                    , height   = gg_height
                    , units    = gg_units
                    , dpi      = gg_depth
                    )#end ggsave

}#end for (d in sequence(ndevice))</code></pre>
<pre><code>## Warning: Removed 2 row(s) containing missing values (geom_path).</code></pre>
<pre class="r"><code># If sought, plot images on screen
if (gg_screen) gg_patch</code></pre>
<pre><code>## Warning: Removed 2 row(s) containing missing values (geom_path).</code></pre>
<p><img src="fates_tower_compare_monthly_files/figure-html/plot-compemean-1.png" width="672" /></p>
<p>Then we plot the mean seasonal cycle for both site measurements/estimates and model predictions. We also include a 68% inter-annual variability band.</p>
<pre class="r"><code>cat0(&quot; + Plot the mean seasonal cycle of site measurements/estimates and model predictions.&quot;)

# Set legends
leg_colours = c(site_colour,hlm_colour)
leg_labels  = c(&quot;Site&quot;,case_model)

gg_emean = list()
for (v in seq_along(var_both)){
   # Load variable
   h        = match(var_both[v],hlm1dvar$vnam)
   h_vnam   = hlm1dvar$vnam [h]
   h_vmean  = paste0(h_vnam,&quot;_mean&quot;)
   h_vqlwr  = paste0(h_vnam,&quot;_qlwr&quot;)
   h_vqupr  = paste0(h_vnam,&quot;_qupr&quot;)
   h_desc   = hlm1dvar$desc [h]
   h_short  = hlm1dvar$short[h]
   h_unit   = hlm1dvar$unit [h]
   h_legend = v == 1 


   # Temporary data table. We convert the classes back to factor.
   h_mmean        = mmean
   h_mmean$source = factor(h_mmean$source,levels=unique(h_mmean$source))

   # Initialise plot (we use line)
   gg_now = ggplot( data    = h_mmean
                  , mapping = aes_string( x      = &quot;month&quot;
                                        , group  = &quot;source&quot;
                                        , colour = &quot;source&quot;
                                        , fill   = &quot;source&quot;
                                        )
                  )#end ggplot
   gg_now = gg_now + scale_colour_manual(name=&quot;&quot;,aesthetics=&quot;colour&quot;,labels=leg_labels,values=leg_colours)
   gg_now = gg_now + scale_colour_manual(name=&quot;&quot;,aesthetics=&quot;fill&quot;  ,labels=leg_labels,values=leg_colours)

   # We only add legend for a single plot.  Patchwork will fix this in the end.
   gg_now = gg_now + geom_ribbon( aes_string(ymin=h_vqlwr,ymax=h_vqupr)
                                , alpha       = alpha_ribbon
                                , show.legend = h_legend
                                , colour      = &quot;transparent&quot;
                                )#end geom_ribbon
   gg_now = gg_now + geom_line( aes_string(y=h_vmean)
                              , lwd = 0.8
                              , show.legend = h_legend
                              )#end geom_line

   
   # Add local annotation
   gg_now = gg_now + labs(title=element_blank())
   gg_now = gg_now + scale_x_continuous( breaks = sequence(12)
                                       , labels = substring(month.abb,1,1)
                                       )#end scale_x_continuous
   gg_now = gg_now + xlab(element_blank())
   gg_now = gg_now + ylab(desc.unit(desc=h_short,unit=untab[[h_unit]],dxpr=TRUE))
   gg_now = gg_now + theme_grey( base_size      = gg_ptsz
                               , base_family    = &quot;Helvetica&quot;
                               , base_line_size = 0.5
                               , base_rect_size = 0.5
                               )#end theme_grey

   # Additional legend settings
   # if (h_legend) gg_now = gg_now + theme( legend.position = &quot;bottom&quot;)

   # Axis settings
   gg_now = gg_now + theme( axis.text.x       = element_text( size   = gg_ptsz
                                                            , margin = unit(rep(0.35,times=4),&quot;char&quot;)
                                                            )#end element_text
                          , axis.text.y       = element_text( size   = gg_ptsz
                                                            , margin = unit(rep(0.35,times=4),&quot;char&quot;)
                                                            )#end element_text
                          , axis.ticks.length = unit(-0.2,&quot;char&quot;)
                          , axis.title.y      = element_text( size = gg_ptsz * 0.9)
                          )#end theme

  # Write plot settings to the list.
  gg_emean[[h_vnam]] = gg_now
}#end for (v in seq_along(var_both)){

# Wrap plots then global settings and x axis.
gg_patch = wrap_plots(gg_emean)
gg_patch = gg_patch + guide_area() + plot_layout(guides=&quot;collect&quot;)
gg_patch = gg_patch + plot_annotation(tag_levels = &quot;a&quot;, title = case_desc)

# Save plots.
for (d in sequence(ndevice)){
   h_output = paste0(&quot;comparison_meanseason-&quot;,case_name,&quot;.&quot;,gg_device[d])
   dummy    = ggsave( filename = h_output
                    , plot     = gg_patch
                    , device   = gg_device[d]
                    , path     = comparison_path
                    , width    = gg_width
                    , height   = gg_height
                    , units    = gg_units
                    , dpi      = gg_depth
                    )#end ggsave

}#end for (d in sequence(ndevice))

# If sought, plot images on screen
if (gg_screen) gg_patch</code></pre>
<p><img src="fates_tower_compare_monthly_files/figure-html/plot-compmmean-1.png" width="672" /></p>
</div>
<div id="taylor-and-bias-variance-diagrams" class="section level2">
<h2>Taylor and bias-variance diagrams</h2>
<p>We now generate a few summary diagrams that allow us to compare the model behaviour for all the variables in the same plot. First, we must first combine all the variables in rows, and leave observations and models in separate columns.</p>
<pre class="r"><code># Re-arrange site data for the Taylor diagram
td_site = emean %&gt;%
          filter(source == 0) %&gt;%
          select( ! source) %&gt;%
          melt(id.vars=&quot;time&quot;,measure.vars=var_both,variable.factor=FALSE,value.name=&quot;site&quot;) %&gt;%
          as_tibble()

# Re-arrange model data for the Taylor diagram
td_model = emean %&gt;%
          filter(source == 1) %&gt;%
          select( ! source) %&gt;%
          melt(id.vars=&quot;time&quot;,measure.vars=var_both,variable.factor=FALSE,value.name=&quot;model&quot;) %&gt;%
          as_tibble()

# Find factor names
v_short = hlm1dvar$short[match(var_both,hlm1dvar$vnam)]

# Combine both data sets.
td_data = as_tibble(merge(x=td_site,y=td_model,by=c(&quot;time&quot;,&quot;variable&quot;))) %&gt;%
          arrange(variable,time) %&gt;%
          mutate( variable = factor(variable) )

#    Split data into seasons, using a simple function. We use the month acronyms so it works
# for both hemispheres.
which_season  = function(x){ 
   sref = rep(c(&quot;DJF&quot;,&quot;MAM&quot;,&quot;JJA&quot;,&quot;SON&quot;),each=3)
   sref=c(sref[-1],sref[1])
   ans = sref[month(x)]
   return(ans)
}#end function (which_season)
td_data = td_data %&gt;% mutate(season = which_season(time))

# Create tibble with seasons as separate models.
td_season = td_data %&gt;% pivot_wider(names_from=&quot;season&quot;,values_from=&quot;model&quot;)</code></pre>
<p>Generate the Taylor diagrams accounting for all variables and separating by season. Multiple model runs can be also provided for model improvement assessment. This is done by function <a href="https://github.com/mpaiao/FATES_Utils/blob/master/RUtils/gg_taylor.r">RUtils/gg_taylor.r</a>). This function is based on <code>plotrix::taylor.diagram</code>, but incorporating more <code>tidyverse</code> elements.</p>
<p><strong>Inputs</strong></p>
<ul>
<li><code>x</code>. Data set (<code>data.frame</code>, <code>data.table</code>, or <code>tibble</code>), it can be coerced to tibble. It is often necessary to rearrange the data, check functions <code>data.table::melt</code> and <code>dplyr::pivot_longer</code> which may help.</li>
<li><code>obser</code>. Column in <code>x</code> that represents the observations. Default is <code>"obs"</code>. This column may contain multiple variables, sites, seasons, or other category, as long as they can be identified by another column in <code>x</code>.</li>
<li><code>model</code>. Column(s) in <code>x</code> that represents the model results. Default is a single column named <code>"mod"</code>. Each row should correspond to the equivalent value in <code>obser</code>.</li>
<li><code>group</code>. Column in <code>x</code> that describes how to classify the data. Each group will have a specific colour in the diagram. If none is provided, a single point will be pooled.</li>
<li><code>panel</code>. Column in <code>x</code> that describes how to split the data. Each panel will be plot in a separate sub-figure in the diagram. If none is provided, a single panel will be plot.</li>
<li><code>model_opts</code> and <code>group_opts</code>. List of options for handling model/group annotation in the legend (used only if more than one model/group exists):
<ul>
<li><code>title</code>. Title for legend caption.</li>
<li><code>label</code>. Labels for models or groups. In the case of model_opts, this must have the same length as variable model. In the case of group_opts, this must match the number of unique groups. If <code>label</code> is not provided, the code will use the same category names as variable model. If variable <code>group</code> is a character, we strongly recomend to use a named vector in which the names match the values in the group column (e.g. <code>group_label = c(class_a = "A", class_b = "B")</code>.</li>
</ul></li>
<li><code>colour_opts</code>. List of options for colours. The following elements can be provided:
<ul>
<li><code>by</code>. In case multiple models and groups are provided, use <code>by</code> to indicate which dimension should be distinguished by colour. Options are <code>"model"</code> or <code>"group"</code>. The other one will be distinguished by shape. In case only one of them have multiple categories, we ignore <code>by</code> and use both shape and colours to distinguish the categories.</li>
<li><code>level</code>. Colours for the categories distinguished by shapes. If <code>NULL</code>, the colours will be automatically assigned. Otherwise, this can be a palette from package <code>RColorBrewer</code>, a palette in package <code>viridis</code>, a function that takes the number of sought colours as the first argument, or a vector with as many colours as categories.</li>
<li><code>reverse</code>. In case colour is a palette or function, reverse it?</li>
</ul></li>
<li><code>shape_opts</code>. List of options for shapes. The following elements can be provided:
<ul>
<li><code>level</code>. List of shapes for the categories distinguished by shapes. It can be a vector of numbers (same as those defined by lty) or characters (similar to <code>ggplot</code>), with as many elements as categories. If <code>NULL</code>, the shapes will be automatically assigned. <em>Important</em>: avoid using many more than 6 shapes because it makes the plot difficult to read.</li>
<li><code>solid</code>. In case shape is <code>NULL</code>, use solid shapes (TRUE or FALSE).</li>
<li><code>size</code>. Size for symbols.</li>
</ul></li>
<li><code>panel_opts</code>. List with options for panels. The following elements can be provided:
<ul>
<li><code>label</code>. Labels, to appear in the sub-plot titles (used only if more than one panel exists). This must match the number of unique groups. If none is provided, the code will use the unique values in variable panel. If variable group is a character, we strongly recomend to use a named vector in which the names match the values in the panel column (e.g. <code>label = c(class_a = "A", class_b = "B")</code>).</li>
<li><code>levels</code>. Type of level to use for panel annotation tags. This follows the same idea of <code>patchwork::plot_annotation</code>. Options are <code>"a"</code> for lowercase letters, <code>"A"</code> for uppercase letters, <code>"1"</code> for numbers, <code>"i"</code> for lowercase Roman numerals, <code>"I"</code> for uppercase Roman numerals. Empty character will skip levels.</li>
<li><code>prefix</code>. String to appear before the tag.</li>
<li><code>suffix</code>. String to appear after the tag and before the panel labels.</li>
<li><code>sep</code>. Separator between tag, prefix, and suffix. There will be always a space between tag and labels if panel_levels is not empty.</li>
</ul></li>
<li><code>axis_opts</code>. List of options for the main axes.
<ul>
<li><code>colour</code>. Colour for main axes.</li>
<li><code>linetype</code>. Line type for main axes.</li>
<li><code>size</code>. Line width for main axes.</li>
</ul></li>
<li><code>sigma_opts</code>, <code>corr_opts</code>, <code>gamma_opts</code>. List of options for the standard deviation of the model (sigma), correlation between model and observations (corr), and standard deviation of residuals (gamma) “axes”:
<ul>
<li><code>name</code>. Name for this “axis”.</li>
<li><code>at</code>. Labels for this axis. If <code>NULL</code> this will be automatically defined.</li>
<li><code>colour</code>. Colour for this axis and labels.</li>
<li><code>linetype</code>. Line type for this axis.</li>
<li><code>size</code>. Line width for this axis.</li>
<li><code>family</code>. Font family for axis and labels.</li>
<li><code>fontsize</code>. Font size for axis and labels.</li>
</ul></li>
<li><code>main_title</code>. General title for the entire figure (single title even for multiple panels).</li>
<li><code>extra_legend</code>. Add extra plot space for legend? <code>TRUE</code> means yes, <code>FALSE</code> (default) means no.</li>
<li><code>base_size</code>. Size for theme.</li>
<li><code>base_family</code>. Family of font type for theme.</li>
<li><code>force_pos</code>. Force to display positive correlation only? Default is <code>FALSE</code>.</li>
</ul>
<p><strong>Output</strong></p>
<p>This function returns a <code>patchwork</code> structure (compatible with <code>ggplot</code>).</p>
<pre class="r"><code># Set labels for variables
group_label        = hlm1dvar$short[match(var_both,hlm1dvar$vnam)]
names(group_label) = var_both
group_label        = mapply(FUN=parse,text=as.list(group_label))

# Generate Taylor diagrams (one per season).
gg_good = gg_taylor( x                  = td_season
                   , obser              = &quot;site&quot;
                   , model              = c(&quot;DJF&quot;,&quot;MAM&quot;,&quot;JJA&quot;,&quot;SON&quot;)
                   , group              = &quot;variable&quot;
                   , panel              = NULL # &quot;season&quot;
                   , model_opts         = list( title = &quot;Season&quot;
                                              , label = c(DJF=&quot;DJF&quot;,MAM=&quot;MAM&quot;,JJA=&quot;JJA&quot;,SON=&quot;SON&quot;)
                                              )#end list
                   , group_opts         = list( title = &quot;Variable&quot;, label = group_label)
                   , colour_opts        = list(by=&quot;model&quot;)
                   , main_title         = paste0(&quot;Taylor Diagram: &quot;,case_desc)
                   , base_size          = gg_ptsz
                   , extra_legend       = FALSE
                   )#end gg_taylor

# Save plots.
for (d in sequence(ndevice)){
   h_output = paste0(&quot;taylor_diag-&quot;,case_name,&quot;.&quot;,gg_device[d])
   dummy    = ggsave( filename = h_output
                    , plot     = gg_good
                    , device   = gg_device[d]
                    , path     = taylor_biasvar_path
                    , width    = gg_width
                    , height   = gg_height
                    , units    = gg_units
                    , dpi      = gg_depth
                    )#end ggsave

}#end for (d in sequence(ndevice))

# If sought, plot images on screen
if (gg_screen) gg_good</code></pre>
<p><img src="fates_tower_compare_monthly_files/figure-html/plot-taylor-1.png" width="672" /></p>
<p>Generate the bias-variance diagrams, accounting for all variables and separating by season. Multiple model runs can be also provided for model improvement assessment. This is done by function <a href="https://github.com/mpaiao/FATES_Utils/blob/master/RUtils/gg_biasvar.r">RUtils/gg_biasvar.r</a>). The bias-variance diagram is inspired in the Taylor diagram, but instead of showing the correlation between reference and predictions, it focus on the properties of the residuals (by definition <span class="math inline">\(r = x_{\mathrm{obser}} - x_{\mathrm{model}}\)</span>), specifically how bias (<span class="math inline">\(\mathrm{Bias}=-\mu_{r}\)</span>) and standard deviation of the residuals contribute to the root mean square error (<span class="math inline">\(\mathrm{RMSE}\)</span>).</p>
<p><strong>Inputs</strong></p>
<ul>
<li><code>x</code>. Data set (<code>data.frame</code>, <code>data.table</code>, or <code>tibble</code>), it can be coerced to tibble. It is often necessary to rearrange the data, check functions <code>data.table::melt</code> and <code>dplyr::pivot_longer</code> which may help.</li>
<li><code>obser</code>. Column in <code>x</code> that represents the observations. Default is <code>"obs"</code>. This column may contain multiple variables, sites, seasons, or other category, as long as they can be identified by another column in <code>x</code>.</li>
<li><code>model</code>. Column(s) in <code>x</code> that represents the model results. Default is a single column named <code>"mod"</code>. Each row should correspond to the equivalent value in <code>obser</code>.</li>
<li><code>group</code>. Column in <code>x</code> that describes how to classify the data. Each group will have a specific colour in the diagram. If none is provided, a single point will be pooled.</li>
<li><code>panel</code>. Column in <code>x</code> that describes how to split the data. Each panel will be plot in a separate sub-figure in the diagram. If none is provided, a single panel will be plot.</li>
<li><code>model_opts</code> and <code>group_opts</code>. List of options for handling model/group annotation in the legend (used only if more than one model/group exists):
<ul>
<li><code>title</code>. Title for legend caption.</li>
<li><code>label</code>. Labels for models or groups. In the case of model_opts, this must have the same length as variable model. In the case of group_opts, this must match the number of unique groups. If <code>label</code> is not provided, the code will use the same category names as variable model. If variable <code>group</code> is a character, we strongly recomend to use a named vector in which the names match the values in the group column (e.g. <code>group_label = c(class_a = "A", class_b = "B")</code>.</li>
</ul></li>
<li><code>colour_opts</code>. List of options for colours. The following elements can be provided:
<ul>
<li><code>by</code>. In case multiple models and groups are provided, use <code>by</code> to indicate which dimension should be distinguished by colour. Options are <code>"model"</code> or <code>"group"</code>. The other one will be distinguished by shape. In case only one of them have multiple categories, we ignore <code>by</code> and use both shape and colours to distinguish the categories.</li>
<li><code>level</code>. Colours for the categories distinguished by shapes. If <code>NULL</code>, the colours will be automatically assigned. Otherwise, this can be a palette from package <code>RColorBrewer</code>, a palette in package <code>viridis</code>, a function that takes the number of sought colours as the first argument, or a vector with as many colours as categories.</li>
<li><code>reverse</code>. In case colour is a palette or function, reverse it?</li>
</ul></li>
<li><code>shape_opts</code>. List of options for shapes. The following elements can be provided:
<ul>
<li><code>level</code>. List of shapes for the categories distinguished by shapes. It can be a vector of numbers (same as those defined by lty) or characters (similar to <code>ggplot</code>), with as many elements as categories. If <code>NULL</code>, the shapes will be automatically assigned. <em>Important</em>: avoid using many more than 6 shapes because it makes the plot difficult to read.</li>
<li><code>solid</code>. In case shape is <code>NULL</code>, use solid shapes (TRUE or FALSE).</li>
<li><code>size</code>. Size for symbols.</li>
</ul></li>
<li><code>panel_opts</code>. List with options for panels. The following elements can be provided:
<ul>
<li><code>label</code>. Labels, to appear in the sub-plot titles (used only if more than one panel exists). This must match the number of unique groups. If none is provided, the code will use the unique values in variable panel. If variable group is a character, we strongly recomend to use a named vector in which the names match the values in the panel column (e.g. <code>label = c(class_a = "A", class_b = "B")</code>).</li>
<li><code>levels</code>. Type of level to use for panel annotation tags. This follows the same idea of <code>patchwork::plot_annotation</code>. Options are <code>"a"</code> for lowercase letters, <code>"A"</code> for uppercase letters, <code>"1"</code> for numbers, <code>"i"</code> for lowercase Roman numerals, <code>"I"</code> for uppercase Roman numerals. Empty character will skip levels.</li>
<li><code>prefix</code>. String to appear before the tag.</li>
<li><code>suffix</code>. String to appear after the tag and before the panel labels.</li>
<li><code>sep</code>. Separator between tag, prefix, and suffix. There will be always a space between tag and labels if panel_levels is not empty.</li>
</ul></li>
<li><code>axis_opts</code>. List of options for the main axes.
<ul>
<li><code>colour</code>. Colour for main axes.</li>
<li><code>linetype</code>. Line type for main axes.</li>
<li><code>size</code>. Line width for main axes.</li>
</ul></li>
<li><code>bias_opts</code>, <code>sigma_opts</code>, <code>rmse</code>_opts`. List of options for the bias, standard deviation of residuals (sigma), and root mean square error (RMSE) “axes” and labels:
<ul>
<li><code>name</code>. Name for this “axis”.</li>
<li><code>at</code>. Labels for this axis. If <code>NULL</code> this will be automatically defined.</li>
<li><code>colour</code>. Colour for this axis and labels.</li>
<li><code>linetype</code>. Line type for this axis.</li>
<li><code>size</code>. Line width for this axis.</li>
<li><code>family</code>. Font family for axis and labels.</li>
<li><code>fontsize</code>. Font size for axis and labels.</li>
</ul></li>
<li><code>main_title</code>. General title for the entire figure (single title even for multiple panels).</li>
<li><code>extra_legend</code>. Add extra plot space for legend? <code>TRUE</code> means yes, <code>FALSE</code> (default) means no.</li>
<li><code>show_nsme</code>. Replace the <span class="math inline">\(\sigma\)</span> axis with the Nash-Sutcliffe model efficiency index? <code>TRUE</code> means yes, <code>FALSE</code> (default) means no. If this is TRUE, the values of sigma_opts$at will be overwritten.</li>
<li><code>base_size</code>. Size for theme.</li>
<li><code>base_family</code>. Family of font type for theme.</li>
</ul>
<p><strong>Output</strong></p>
<p>This function returns a <code>patchwork</code> structure (compatible with <code>ggplot</code>).</p>
<pre class="r"><code># Temporary, load function
source(file.path(util_path,&quot;gg_biasvar.r&quot;))

# Set labels for variables
group_label        = hlm1dvar$short[match(var_both,hlm1dvar$vnam)]
names(group_label) = var_both
group_label        = mapply(FUN=parse,text=as.list(group_label))

# Generate bias-variance diagrams (one per season).
gg_good = gg_biasvar( x                  = td_season
                    , obser              = &quot;site&quot;
                    , model              = c(&quot;DJF&quot;,&quot;MAM&quot;,&quot;JJA&quot;,&quot;SON&quot;)
                    , group              = &quot;variable&quot;
                    , panel              = NULL # &quot;season&quot;
                    , model_opts         = list( title = &quot;Season&quot;
                                               , label = c(DJF=&quot;DJF&quot;,MAM=&quot;MAM&quot;,JJA=&quot;JJA&quot;,SON=&quot;SON&quot;)
                                               )#end list
                    , group_opts         = list( title = &quot;Variable&quot;, label = group_label)
                    , colour_opts        = list(by=&quot;model&quot;)
                    , main_title         = paste0(&quot;Bias-Variance Diagram: &quot;,case_desc)
                    , base_size          = gg_ptsz
                    , show_nsme          = FALSE
                    , extra_legend       = FALSE
                    )#end gg_taylor
# Save plots.
for (d in sequence(ndevice)){
   h_output = paste0(&quot;biasvar_diag-&quot;,case_name,&quot;.&quot;,gg_device[d])
   dummy    = ggsave( filename = h_output
                    , plot     = gg_good
                    , device   = gg_device[d]
                    , path     = taylor_biasvar_path
                    , width    = gg_width
                    , height   = gg_height
                    , units    = gg_units
                    , dpi      = gg_depth
                    )#end ggsave

}#end for (d in sequence(ndevice))

# If sought, plot images on screen
if (gg_screen) gg_good</code></pre>
<p><img src="fates_tower_compare_monthly_files/figure-html/plot-biasvar-1.png" width="672" /></p>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
