<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Marcos Longo" />


<title>Generating ELM/CLM domain and surface files for a single point</title>

<script src="site_libs/header-attrs-2.8/header-attrs.js"></script>
<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/darkly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>





<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">FATES Utilities</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="make_fates_met_driver.html">Meteorological driver</a>
</li>
<li>
  <a href="make_fates_domain+surface.html">Surface/Domain files</a>
</li>
<li>
  <a href="create_case_hlm-fates.html">Set up single-site runs</a>
</li>
<li>
  <a href="fates_plot_monthly.html">Single-site visualisation with R</a>
</li>
<li>
  <a href="make_fates_tower_summary.html">Make tower-based benchmark file</a>
</li>
<li>
  <a href="fates_tower_compare_monthly.html">Evaluate FATES against tower</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Generating ELM/CLM domain and surface files for a single point</h1>
<h4 class="author">Marcos Longo</h4>
<h4 class="date">16-Jun-2021</h4>

</div>


<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This document shows how to generate domain and surface files for a single point of interest. This is needed for when setting a new site. Currently this script simply uses existing domain and surface files, extracts information from the nearest grid cell, and complements with site-specific information you might have.</p>
</div>
<div id="reset-session" class="section level1">
<h1>Reset session</h1>
<p>Use this chunk to fully reset R.</p>
<pre class="r"><code># Unload all packages except for the R default ones
plist = names(sessionInfo()$otherPkgs)
if (length(plist) &gt; 0){
   dummy = sapply(X=paste0(&quot;package:&quot;,plist),FUN=detach,character.only=TRUE,unload=TRUE)
}#end if (length(plist) &gt; 0)


# Remove all variables
rm(list=ls())

# Reset warnings
options(warn=0)

# Close all plots
invisible(graphics.off())

# Clean up
invisible(gc())</code></pre>
</div>
<div id="main-settings" class="section level1">
<h1>Main settings</h1>
<div id="required-packages" class="section level2">
<h2>Required packages</h2>
<p>Load some packages. By default, we skip the warning messages, but it may be a good idea to visualise them if it is the first time running.</p>
<pre class="r"><code>isfine = c( data.table = require(data.table,quietly=TRUE,warn.conflicts=FALSE)
          , fields     = require(fields    ,quietly=TRUE,warn.conflicts=FALSE)
          , lubridate  = require(lubridate ,quietly=TRUE,warn.conflicts=FALSE)
          , ncdf4      = require(ncdf4     ,quietly=TRUE,warn.conflicts=FALSE)
          , purrr      = require(purrr     ,quietly=TRUE,warn.conflicts=FALSE)
          , reshape2   = require(reshape2  ,quietly=TRUE,warn.conflicts=FALSE)
          , tidyverse  = require(tidyverse ,quietly=TRUE,warn.conflicts=FALSE)
          )#end c
if (! all(isfine)){
   cat0(&quot; List of required packages, and the success status loading them:\n&quot;)
   print(isfine)
   stop(&quot; Some packages are missing and must be installed.&quot;)
}</code></pre>
</div>
<div id="path-and-file-location" class="section level2">
<h2>Path and file location</h2>
<p>Set paths and files for input and output.</p>
<ul>
<li><strong>main_path</strong>. The main path for processing data. The output path will be generated here.</li>
<li><strong>input_path</strong>. The location where existing surface and domain netcdf files are located</li>
<li><strong>output_path</strong>. The main output path for the data. A sub-directory for this site will be created.</li>
</ul>
<pre class="r"><code>main_path   = file.path(path.expand(&quot;~&quot;),&quot;Documents&quot;,&quot;LocalData&quot;,&quot;TowerData&quot;,&quot;Paracou&quot;,&quot;make_single_site&quot;)
input_path  = file.path(main_path,&quot;input_netcdf&quot;)
output_path = file.path(path.expand(&quot;~&quot;),&quot;Data&quot;,&quot;FATES_DataSets&quot;)</code></pre>
<p>Set the URL for the input surface data. <em>This is normally a gridded data file</em>, not a single-site one. We will only download the data in case we cannot locate these files at <code>input_netcdf</code>. If you have your own set of input data, set a dummy URL with the actual file name. For example, if you have the domain file <code>my_surface_grid_file.nc</code>, set <code>url.surfgrid="https://localhost/my_surface_grid_file.nc"</code>.</p>
<pre class="r"><code>url_surfgrid = &quot;https://svn-ccsm-inputdata.cgd.ucar.edu/trunk/inputdata/lnd/clm2/surfdata_map/release-clm5.0.24/surfdata_0.125x0.125_hist_16pfts_Irrig_CMIP6_simyr2005_c190613.nc&quot;</code></pre>
</div>
<div id="author-information" class="section level2">
<h2>Author information</h2>
<p>Provide information about yourself. This will be included in the netCDF headers. In case you do not want to specify any of them, set them to <code>NA_character_</code></p>
<ul>
<li><strong>author_name</strong>. Person who is generating these files (typically it’s you).</li>
<li><strong>author_email</strong>. Contact email (so people can reach out to you if problems arise).</li>
</ul>
<pre class="r"><code>author_name  = &quot;This Is You&quot;
author_email = &quot;yourself@somewhere.gov&quot;</code></pre>
</div>
<div id="site-information" class="section level2">
<h2>Site information</h2>
<p>Provide some basic information about the site:</p>
<ul>
<li><strong>xid</strong>. Unique site ID.</li>
<li><strong>site_desc</strong>. Site description (to be added to the NetCDF files headers).</li>
<li><strong>site_lon</strong>. Longitude (degrees east).</li>
<li><strong>site_lat</strong>. Latitude (degrees north).</li>
<li><strong>site_alt</strong>. Altitude (metres above sea level).</li>
<li><strong>dxy</strong>. Intended grid size.</li>
<li><strong>site_pcsand</strong>; <strong>site_pcclay</strong>. Percentage of sand and clay, respectively. They should be both be limited between 0 and 100., and their sum shall not exceed 100. Silt fraction will be derived from these fractions. If these fractions are not known, set them to <code>NA</code>. If texture information is provided, we assume that all layers have the same texture (this should be revisited once I figure out the soil layers).</li>
<li><strong>site_organic</strong>. Soil organic content <span class="math inline">\(\left[\mathrm{kg\,m^{-3}}\right]\)</span>. For now we use this value to rescale the gridded organic content of all input layers.</li>
<li><strong>site_bedrock</strong>. Soil depth to bedrock <span class="math inline">\(\left[\mathrm{m}\right]\)</span>. In case depth is unknown, leave it as <code>NA_real_</code>.</li>
<li><strong>undef</strong>. A number to denote missing values. This is needed by NetCDF, but the data should not have any.</li>
<li><strong>force_natural</strong>. Should we overwrite the fraction cover of global gridded data set, so natural vegetation becomes 100%?</li>
</ul>
<pre class="r"><code>xid           = &quot;paracouGUF&quot;
site_desc     = &quot;Guyaflux tower at Paracou, French Guiana&quot;
dat_version   = &quot;1.5&quot;
site_lon      = -52.912222
site_lat      =   5.281667
site_alt      =  30.000000
dxy           =  1.0
site_xsand    = NA_real_ # 56.2
site_xclay    = NA_real_ # 37.2
site_organic  = NA_real_ # 31.1
site_bedrock  = NA_real_
undef         = -9999.99
force_natural = TRUE</code></pre>
<p>Additional settings for retrieving the surface gridded data</p>
<ul>
<li><strong>pcveg_min</strong>. Minimum percentage of natural vegetation to consider when loading surface grid. This can be useful to avoid selecting a grid cell over non-natural vegetation when using a site in heavily degraded areas.</li>
<li><strong>landfrac_min</strong>. Minimum fraction of land to consider when loading surface grid. This can be useful to avoid selecting a grid cell over the ocean when using a coastal site.</li>
</ul>
<pre class="r"><code>pcveg_min    = 8.00
landfrac_min = 0.50</code></pre>
<p>This concludes the initial settings. From this point on, you may not need to change anything, unless you are debugging or adding new features.</p>
</div>
</div>
<div id="data-processing" class="section level1">
<h1>Data processing</h1>
<div id="check-inputs" class="section level2">
<h2>Check inputs</h2>
<p>Ensure the input and output paths</p>
<pre class="r"><code>dummy = dir.create(input_path ,showWarnings=FALSE,recursive=TRUE)</code></pre>
<p>First, we check whether the input surface data file is already available at the input path. In case it is not, we download it. Because some of the files may be very large, we temporarily expand R’s default timeout for the operation to one day.</p>
<pre class="r"><code># Find base name
input_surfgrid = file.path(input_path,basename(url_surfgrid))

# Download data in case they are not found.  Often these files are huge, so we tempo
if (! file.exists(input_surfgrid)){
  orig.timeout = getOption(&quot;timeout&quot;)
  dummy = options(timeout=86400)
  dummy = download.file(url=url_surfgrid,destfile=input_surfgrid)
  dummy = options(timeout=orig.timeout)
}#end if (! file.exists(input_surfgrid))</code></pre>
</div>
<div id="output-names" class="section level2">
<h2>Output names</h2>
<p>Build the output file names, following the ELM/CLM convention.</p>
<pre class="r"><code># Labels for describing the data set.
ymd_now = today(tzone = &quot;UTC&quot;)
ymd_lab = sprintf(&quot;%4.4i%2.2i%2.2i&quot;,year(ymd_now),month(ymd_now),day(ymd_now))

# Tag specific for this site, grid, and version (used for file and path names).
site_tag  = paste0(&quot;1x1pt-&quot;,xid,&quot;_v&quot;,dat_version,&quot;_c&quot;,ymd_lab)

#    Set output path to be the same as the site tag.
site_path   = file.path(output_path,site_tag)
dummy       = dir.create(site_path  ,recursive=TRUE,showWarnings=FALSE)

# Domain file.  In case the file exists, remove it.
output_domain   = file.path(site_path,paste0(&quot;domain.lnd.&quot;,site_tag,&quot;_navy.nc&quot;))
if (file.exists(output_domain)) file.remove(output_domain)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code># Surface data file
output_surfdata = file.path(site_path,paste0(&quot;surfdata_&quot;,site_tag,&quot;.nc&quot;))
if (file.exists(output_surfdata)) file.remove(output_surfdata)</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="domain-file" class="section level2">
<h2>Domain file</h2>
<p>The domain file is written entirely from the information provided at the beginning of this document.</p>
<p>First, we set the centre and edge of the grid cells. Make sure longitude is always set from <span class="math inline">\(0^\circ\)</span> to <span class="math inline">\(360^\circ\)</span>, and that the centre of the latitude points are not too close to the poles.</p>
<pre class="r"><code># Find precision for the coordinates (typically 1% of the grid size).
cprec = -floor(log10(dxy*0.01))

# Standardise coordinates (and make sure latitude cannot exceed the poles).
clon  = round(site_lon,cprec) %% 360.
clat  = max(-90,min(90-0.5*dxy,round(site_lat,cprec)))

# Find edges
wlon = (clon - 0.5 * dxy) %% 360.
elon = (clon + 0.5 * dxy) %% 360.
slat = max(-90.,clat - 0.5 * dxy)
nlat = min(+90.,clat + 0.5 * dxy)</code></pre>
<p>Find the area of this grid cell, in steradians, using the definition of solid angle <span class="math inline">\(\omega\)</span>: <span class="math display">\[\begin{align}
&amp; \omega = \left[\sin{\left(\varphi_{N}\right)} - \sin{\left(\varphi_{S}\right)} \right] \, \left[ \left(\lambda_{E} - \lambda_{W} \right) \mod{2\,\pi{}} \right]
\end{align}\]</span> where <span class="math inline">\(\varphi_{S}\)</span> and <span class="math inline">\(\varphi_{N}\)</span> are the latitudes of the southern and northern edges [<span class="math inline">\(\mathrm{rad}\)</span>], and <span class="math inline">\(\lambda_{W}\)</span> and <span class="math inline">\(\lambda_{E}\)</span> are the longitude of the western and eastern edges [<span class="math inline">\(\mathrm{rad}\)</span>]. The modulo operator ensures that the results are correct when the centre of the grid cell crosses the Greenwich meridian.</p>
<pre class="r"><code># Turn angles to radians.
wlonr = wlon * pi / 180.
elonr = elon * pi / 180.
slatr = slat * pi / 180.
nlatr = nlat * pi / 180.

# Find solid angle area (assuming radius=1 so results are in steradians).
solid_angle = (sin(nlatr)-sin(slatr)) * ((elonr-wlonr) %% (2*pi))</code></pre>
<p>Define the dimensions for the new file. It should be always a single point:</p>
<pre class="r"><code># Dimensions are unitless
ni = ncdim_def( name=&quot;ni&quot;,units=&quot;&quot;,vals=sequence(1L),create_dimvar=FALSE)
nj = ncdim_def( name=&quot;nj&quot;,units=&quot;&quot;,vals=sequence(1L),create_dimvar=FALSE)
nv = ncdim_def( name=&quot;nv&quot;,units=&quot;&quot;,vals=sequence(4L),create_dimvar=FALSE)

# List of dimensions
ij  = list(ni,nj)
vij = list(nv,ni,nj)</code></pre>
<p>Create a list with the variables to be added to the single-point domain file. Each list element contains the following variables.</p>
<ul>
<li><strong>vals</strong>. The values to be included in the variables.</li>
<li><strong>long</strong>. The variable long (and descriptive) name.</li>
<li><strong>unit</strong>. The variable units. In case the variable does not have units, leave it blank (<code>""</code>).</li>
<li><strong>dims</strong>. The variable dimensions (a list with the dimensions defined above).</li>
<li><strong>attx</strong>. Other relevant information to be added as attributes. In case no additional attribute is needed, set this to <code>list()</code></li>
</ul>
<pre class="r"><code># List of data to write.
nco_dat      = list()
nco_dat$xc   = list( vals = array(data = clon                  , dim =   c(1,1))
                   , long = &quot;longitude of the grid cell centre&quot;
                   , unit = &quot;degrees_east&quot;
                   , dims = ij
                   , prec = &quot;double&quot;
                   , attx = list( bounds = &quot;xv&quot;)
                   )#end list
nco_dat$yc   = list( vals = array(data = clat                  , dim =   c(1,1))
                   , long = &quot;latitude of the grid cell centre&quot;
                   , unit = &quot;degrees_north&quot;
                   , dims = ij
                   , prec = &quot;double&quot;
                   , attx = list( bounds = &quot;yv&quot;)
                   )#end list
nco_dat$xv   = list( vals = array(data = c(wlon,elon,elon,wlon), dim = c(4,1,1))
                   , long = &quot;longitude of grid cell vertices&quot;
                   , unit = &quot;degrees_east&quot;
                   , dims = vij
                   , prec = &quot;double&quot;
                   , attx = list(note = &quot;Vertex order: 1 - SW; 2 - SE; 3 - NE; 4 - NW&quot;)
                   )#end list
nco_dat$yv   = list( vals = array(data = c(slat,slat,nlat,nlat), dim = c(4,1,1))
                   , long = &quot;latitude of grid cell vertices&quot;
                   , unit = &quot;degrees_north&quot;
                   , dims = vij
                   , prec = &quot;double&quot;
                   , attx = list(note = &quot;Vertex order: 1 - SW; 2 - SE; 3 - NE; 4 - NW&quot;)
                   )#end list
nco_dat$mask = list( vals = array(data =          1L           , dim =   c(1,1))
                   , long = &quot;land domain mask&quot;
                   , unit = &quot;&quot;
                   , dims = ij
                   , prec = &quot;integer&quot;
                   , attx = list( note        = &quot;Unitless.&quot;
                                , coordinates = &quot;xc yc&quot;
                                , classes     = &quot;0 - water (not active); 1 - land (active)&quot;
                                )#end list
                   )#end list
nco_dat$frac = list( vals = array(data =          1.           , dim =   c(1,1))
                   , long = &quot;fraction of grid cell that is active&quot;
                   , unit = &quot;&quot;
                   , dims = ij
                   , prec = &quot;double&quot;
                   , attx = list( note        = &quot;Unitless.&quot;
                                , coordinates = &quot;xc yc&quot;
                                , filter1     = paste0( &quot;error if frac&gt; 1.0+eps or &quot;
                                                      , &quot;frac &lt; 0.0-eps; eps = 0.1000000E-11&quot;
                                                      )#end paste0
                                , filter2     = paste0( &quot;limit frac to [fminval,fmaxval];&quot;
                                                      , &quot;fminval= 0.1000000E-02 fmaxval=  1.000000&quot;
                                                      )#end paste0
                                )#end list
                   )#end list
nco_dat$area = list( vals = array(data = solid_angle           , dim =   c(1,1))
                   , long = &quot;area (solid angle) of grid cell, in steradian&quot;
                   , unit = &quot;sr&quot;
                   , dims = ij
                   , prec = &quot;double&quot;
                   , attx = list( coordinates = &quot;xc yc&quot;)
                   )#end list</code></pre>
<p>Define the netCDF variables for the output variables.</p>
<pre class="r"><code>nco_vlist = list()
for (v in seq_along(nco_dat)){
   # Load information for this variable.
   v_vnow   = names(nco_dat)[v]       # Variable name
   v_long   = nco_dat[[v_vnow]]$long  # Variable description (&quot;long name&quot;)
   v_unit   = nco_dat[[v_vnow]]$unit  # Units
   v_dims   = nco_dat[[v_vnow]]$dims  # Variable dimensions
   v_prec   = nco_dat[[v_vnow]]$prec  # Variable type

   # Define netCDF variable
   nco_vlist[[v_vnow]] = ncvar_def( name     = v_vnow
                                  , units    = v_unit
                                  , dim      = v_dims
                                  , longname = v_long
                                  , prec     = v_prec
                                  )#end ncvar_def
}#end for (v in seq_along(nci_vlist))</code></pre>
<p>Create the output netCDF file.</p>
<pre class="r"><code># Create the netCDF connection
if (&quot;nc_domaout&quot; %in% ls()){ dummy=nc_close(nc_domaout); file.remove(output_domain); rm(nc_domaout)}
nc_domaout = nc_create(filename=output_domain,vars=nco_vlist)

# Define the code developer information (indirect way so the email is not visible).
developer_name  = c( 111L, 103L, 110L, 111L,  76L,  32L, 115L, 111L,  99L, 114L,  97L,  77L)
developer_email = c( 118L, 111L, 103L,  46L, 108L,  98L, 108L,  64L, 111L, 103L, 110L, 111L
                   , 108L, 109L)

# Generate information about this file.
glob_att = list( title           = paste0( &quot;Domain file for &quot;,site_desc,&quot;.&quot;)
               , version         = dat_version
               , date_created    = paste0(as.character(now(tzone=&quot;UTC&quot;)),&quot; UTC&quot;)
               , source_code     = &quot;make_fates_domain+surface.Rmd&quot;
               , code_notes      = &quot;Domain file compatible with ELM-FATES and CLM-FATES&quot;
               , code_developer  = paste0( intToUtf8(rev(developer_name))
                                         ,&quot; &lt;&quot;
                                         , intToUtf8(rev(developer_email))
                                         ,&quot;&gt;&quot;
                                         )#end paste0
               , file_author     = paste0(author_name,&quot; &lt;&quot;,author_email,&quot;&gt;&quot;)
               )#end list

# Add information to the global attribute list
for (l in seq_along(glob_att)){
   # Current attribute information
   att_name  = names(glob_att)[l]
   att_value = glob_att[[l]]

   # Add attribute 
   dummy = ncatt_put(nc=nc_domaout,varid=0,attname=att_name,attval=att_value)
}#end for (l in seq_along(global_att))</code></pre>
<p>Populate the netCDF with the domain variables, and include the attributes for each variable.</p>
<pre class="r"><code>for (v in seq_along(nco_dat)){
   # Retrieve variable information
   v_vnow  = names(nco_dat)[v]
   nco_now = nco_dat[[v_vnow]]

   # Add variable values
   dummy = ncvar_put(nc = nc_domaout,varid=v_vnow,vals=nco_now$vals)

   # Add extra attributes
   for (a in seq_along(nco_now$attx)){
      # Retrieve attribute information
      a_name  = names(nco_now$attx)[a]
      a_value = nco_now$attx[[a]] 
      
      dummy = ncatt_put(nc = nc_domaout, varid=v_vnow,attname=a_name,attval=a_value)
   }#end for (a in seq_along(v_attx))
}#end for (v in seq_along(nco_vlist))</code></pre>
<p>Save new netCDF, and close the output file. We remove the connection from memory.</p>
<pre class="r"><code>   dummy = nc_close(nc_domaout)
   rm(nc_domaout)</code></pre>
</div>
</div>
<div id="surface-data-file" class="section level1">
<h1>Surface data file</h1>
<p>To generate the grid surface data file, we will load an existing surface data file, locate the grid cell that is the closest to the point of interest, abd extract the data. For some of the variables, such as soil texture and soil organic carbon, there may be local observations. If this is the case, we replace the gridded information with the local observations.</p>
<div id="load-the-gridded-surface-data" class="section level2">
<h2>Load the gridded surface data</h2>
<p>Open the surface data file, and retrieve the grid dimensions.</p>
<pre class="r"><code># Open gridded surface data
if (&quot;nc_gridin&quot; %in% ls()){dummy=nc_close(nc_gridin);rm(nc_gridin)}
nc_gridin = nc_open(filename=input_surfgrid)</code></pre>
<p>Retrieve global attributes from the input file, and add information about this processing.</p>
<pre class="r"><code># Retrieve original attributes. We only make minor edits.
glob_att = ncatt_get(nc = nc_gridin, varid = 0)


# Define the code developer information (indirect way so the email is not visible).
developer_name  = c( 111L, 103L, 110L, 111L,  76L,  32L, 115L, 111L,  99L, 114L,  97L,  77L)
developer_email = c( 118L, 111L, 103L,  46L, 108L,  98L, 108L,  64L, 111L, 103L, 110L, 111L
                   , 108L, 109L)

# Get current time for the log
create_time = paste0(as.character(now(tzone=&quot;UTC&quot;)),&quot; UTC&quot;)

# Generate information about this file.
glob_new = list( title           = paste0( &quot;Domain file for &quot;,site_desc,&quot;.&quot;)
               , Version         = dat_version
               , Revision_Id     = paste0( &quot;$Id: make_fates_domain+surface.Rmd&quot;
                                         , &quot; 0 &quot;,create_time,Sys.info()[&quot;user&quot;],&quot;$&quot;
                                         )#end paste0
               , History_Log     = paste0( &quot;created on: &quot;, create_time)
               , Logname         = paste0( &quot;code originally developed by &quot;
                                         , intToUtf8(rev(developer_name))
                                         ,&quot; &lt;&quot;
                                         , intToUtf8(rev(developer_email))
                                         ,&quot;&gt;&quot;
                                         )#end paste0
               , Host            = Sys.info()[&quot;nodename&quot;]
               , File_Author     = paste0(author_name,&quot; &lt;&quot;,author_email,&quot;&gt;&quot;)
               )#end list

# Update attribute list
glob_att = modifyList( glob_att, glob_new)</code></pre>
<p>Load coordinates, and identify the nearest grid point.</p>
<pre class="r"><code># Retrieve longitude and latitude
in_lon   = melt(ncvar_get(nc=nc_gridin,&quot;LONGXY&quot;      )); names(in_lon)  = c(&quot;x&quot;,&quot;y&quot;,&quot;lon&quot;   )
in_lat   = melt(ncvar_get(nc=nc_gridin,&quot;LATIXY&quot;      )); names(in_lat)  = c(&quot;x&quot;,&quot;y&quot;,&quot;lat&quot;   )
in_veg   = melt(ncvar_get(nc=nc_gridin,&quot;PCT_NATVEG&quot;  )); names(in_veg)  = c(&quot;x&quot;,&quot;y&quot;,&quot;pcveg&quot; )
in_land  = melt(ncvar_get(nc=nc_gridin,&quot;LANDFRAC_PFT&quot;)); names(in_land) = c(&quot;x&quot;,&quot;y&quot;,&quot;fland&quot; )

# Create a tibble with coordinates
in_coord = tibble(merge(merge(merge(in_lon,in_lat),in_veg),in_land)) 


# Define function that takes longitude/latitude and find distances.
rdist_wrap = function(lon,lat,lon0,lat0){
   ans = c(fields::rdist.earth(x1=cbind(lon0,lat0),x2=cbind(lon,lat),miles=FALSE))
   return(ans)
}#end function

# Find the distances.
in_coord = in_coord %&gt;%
           mutate( dist = rdist_wrap(lon=lon,lat=lat,lon0=clon,lat0=clat))


# Select the nearest neighbour
in_near = in_coord %&gt;% 
          filter((pcveg &gt; pcveg_min) &amp; (fland &gt; landfrac_min)) %&gt;% 
          slice(which.min(dist))
in_xy   = in_near %&gt;% select(c(x,y)) %&gt;% unlist(); names(in_xy) = NULL</code></pre>
<p>Load all the dimensions from the input netCDF file, and create dimensions for the output file that are essentially copies of the input. The only exceptions are the longitude and latitude, which will be always one (single site).</p>
<pre class="r"><code># List of dimension names
nc_dnames = names(nc_gridin$dim)

# Loop through all the dimensions
nc_dims = list()
for (d in seq_along(nc_dnames)){
   # Retrieve dimensions
   d_dname   = nc_dnames[d]
   nc_dimnow = nc_gridin$dim[[d_dname]]

   # Fix dimensions and values for longitude and latitude.
   if (d_dname %in% c(&quot;lsmlon&quot;,&quot;lsmlat&quot;)){
      # Longitude or latitude, make data a single point
      nc_dimnow = modifyList( x   = nc_dimnow
                            , val = list( len = 1L, vals = sequence(1L))
                            )#end modifyList
   # }else if (d_dname %in% &quot;time&quot;){
   #    # Time is not properly set in some nc maps.
   #    nc_dimnow = modifyList( x   = nc_dimnow
   #                          , val = list(vals=seq_along(nc_dimnow$vals))
   #                          )#end modifyList
   }#end if (nc_dimnow)

   # Decide whether to append calendar information
   if (nc_dimnow$unlim &amp;&amp; (! is.null(nc_dimnow$calendar))){
      nc_calendar = nc_dimnow$calendar
   }else{
      nc_calendar = NA_character_
   }#end if (nc_dimnow$unlim &amp;&amp; (! is.null(nc_dimnow$calendar)))

      
   # Create dimensions. Distinguish unlimited and limited dimensions (if needed).
   nc_dims[[d_dname]] = ncdim_def( name          = d_dname
                                 , units         = nc_dimnow$units
                                 , vals          = nc_dimnow$vals
                                 , unlim         = nc_dimnow$unlim
                                 , create_dimvar = nc_dimnow$create_dimvar
                                 , calendar      = nc_calendar
                                 )#end ncdim_def
}#end for (d in seq_along(nc_dnames))</code></pre>
<p>Define variables that should feature in the output. Every variable in the input should be in the output too.</p>
<pre class="r"><code># List of variable names
nc_vnames = names(nc_gridin$var)

# This will contain variables that were actually used. We will create dummy variables for 
# those not used, to ensure they exist in the output.
nc_dimused = character(0)

# Loop through all the variables, retrieve data and settings
nc_vars    = list()
nc_values  = list()
for (v in seq_along(nc_vnames)){
   # Retrieve variable information
   v_vname = nc_vnames[v]
   v_vinfo = nc_gridin$var [[v_vname]]
   v_vlong = v_vinfo$longname
   v_vunit = v_vinfo$unit
   v_vprec = if( v_vinfo$prec %in% &quot;int&quot;){&quot;integer&quot;}else{v_vinfo$prec}
   v_vmiss = if( v_vinfo$prec %in% c(&quot;float&quot;,&quot;double&quot;)){v_vinfo$missval}else{NULL}

   # Switch the longitude and latitude dimensions with point
   if (is.null(v_vinfo$varsize)){
      # Dummy dimensions
      v_count = NA
      v_start = NA
      v_vdims = list()
   }else{
      # Load count, and assume initially that all dimensions start at 1.
      v_count = v_vinfo$varsize
      v_start = rep(1L,times=length(v_count))

      # Find dimensions 
      v_dname = c(unlist(do.call(rbind,v_vinfo$dim)[,&quot;name&quot;]))
      v_vdims = nc_dims[v_dname]
      
      # Find longitude and latitude dimensions
      ixy  = match(c(&quot;lsmlon&quot;,&quot;lsmlat&quot;),v_dname)
      sel  = ! is.na(ixy)

      # Make sure we only read the data from the nearest neighbour
      v_count[ixy[sel]]   = c(1,1)[sel]
      v_start[ixy[sel]]   = in_xy [sel]
      names(v_start) = NULL
   }#end if (length(v_start) == 0)

   # Load information to define the data set.
   nc_vars[[v_vname]] = ncvar_def( name     = v_vname
                                 , units    = v_vunit
                                 , dim      = v_vdims
                                 , missval  = v_vmiss
                                 , longname = v_vlong
                                 , prec     = v_vprec
                                 )#end ncvar_def

   # Load the data 
   nc_values[[v_vname]] = ncvar_get( nc             = nc_gridin
                                   , varid          = v_vname
                                   , start          = v_start
                                   , count          = v_count
                                   , collapse_degen = FALSE
                                   )#end ncvar_get

   # Update the list of dimensions used.
   nc_dimused = sort(unique(c(nc_dimused,names(v_vdims))))
}#end for (v in seq_along(nc_vnames))</code></pre>
<p>Create dummy variables for unused dimensions. It may not be necessary, but this ensures every variable is included.</p>
<pre class="r"><code># Make data set
is_unused = which(! (names(nc_dims) %in% nc_dimused))
for (u in is_unused){
   # Retrieve dimension information
   u_dname = names(nc_dims)[u]
   un_dims = nc_dims[[u_dname]]
   u_dlong = paste0(&quot;Dummy variable to retain dimension &quot;,un_dims$longname)
   u_dunit = un_dims$units
   u_dvals = un_dims$vals
   u_dprec = typeof(u_dvals)

   # Load information to define the data set.
   nc_vars[[u_dname]] = ncvar_def( name     = u_dname
                                 , units    = u_dunit
                                 , dim      = un_dims
                                 , longname = u_dlong
                                 , prec     = u_dprec
                                 )#end ncvar_def

   # Load the data 
   nc_values[[u_dname]] = u_dvals
   
}#end for (u in is_unused)</code></pre>
<p>In case texture and soil organic content were provided, we use the site-specific information instead. Currently the site-specific soil texture will be assumed constant, and the site-specific soil organic contant will be used to re-scale all the layers. We also replace the longitude and latitude information with the site-specific information. Finally, in case <code>force_natural</code> is true, we impose percentage of natural vegetation to 100%.</p>
<pre class="r"><code># Re-set coordinates
nc_values$LONGXY = 0. * nc_values$LONGXY + clon
nc_values$LATIXY = 0. * nc_values$LATIXY + clat

# Re-define percentage of natural vegetation to 100%, and other classes to 0%
if (force_natural){
   nc_values$PCT_NATVEG  = 0. * nc_values$PCT_NATVEG + 100.
   nc_values$PCT_URBAN   = 0. * nc_values$PCT_URBAN
   nc_values$PCT_CROP    = 0. * nc_values$PCT_CROP
   nc_values$PCT_WETLAND = 0. * nc_values$PCT_WETLAND
   nc_values$PCT_LAKE    = 0. * nc_values$PCT_LAKE
   nc_values$PCT_GLACIER = 0. * nc_values$PCT_GLACIER
}#end if (force_natural)


# In case texture was defined, set the values.
if (! ( is.na(site_xsand) || is.na(site_xclay) )){
   # Find silt fraction
   site_xsilt = 100. - site_xsand - site_xclay

   # Set a vector with textures to test whether or not to use site-specific data
   site_xtext = c(site_xsand,site_xsilt,site_xclay)

   # Make sure the texture provided is valid.
   if (all( (site_xtext &gt;= 0.) &amp; (site_xtext &lt;= 100.) ) ){
      # Replace sand and clay with the site-specific data
      nc_values$PCT_SAND = 0. * nc_values$PCT_SAND + site_xsand
      nc_values$PCT_CLAY = 0. * nc_values$PCT_CLAY + site_xclay

      # Update global attribute list to inform that the data are site-specific
      map_soil_texture_file = &quot;site-specific information&quot;
      glob_att = modifyList( x   = glob_att
                           , val = list( map_soil_texture_file = map_soil_texture_file )
                           )#end modifyList
   }#end if (all( (site_xtext =&gt; 0.) &amp; (site_xtext &lt;= 100.) ))
}#end if (! ( is.na(site_xsand) || is.na(site_xclay) ))

# In case site-specific organic content was defined, rescale the gridded values.
is_site_organic = ! is.na(site_organic)
if (is_site_organic){
   f_scal = site_organic / max(c(nc_values$ORGANIC))
   nc_values$ORGANIC = f_scal * nc_values$ORGANIC   

   # Update global attribute list to inform that the data are site-specific
   map_soil_organic_file = paste0( glob_att$map_soil_texture_file
                                 ,&quot; scaled with site-specific information.&quot;)
   glob_att = modifyList( x   = glob_att
                        , val = list( map_soil_texture_file = &quot;site-specific information&quot; )
                        )#end modifyList
}#end if (! is.na(site_organic))</code></pre>
<p>In case depth to bedrock in known, include it in the list of variables.</p>
<pre class="r"><code>if (! is.na(site_bedrock)){
   # Append depth to bedrock to surface data.
   nc_vars$zbedrock = ncvar_def( name     = &quot;zbedrock&quot;
                               , units    = &quot;m&quot;
                               , dim      = nc_dims[c(&quot;lsmlon&quot;,&quot;lsmlat&quot;)]
                               , missval  = nc_gridin$var$PCT_SAND$missval
                               , longname = &quot;soil depth&quot;
                               )#end ncvar_def 

   # Append value to the list of values
   nc_values$zbedrock = array(data=site_bedrock,dim=c(1,1))
}#end if (! is.na(site_bedrock))</code></pre>
<p>Variable <code>T_BUILDING_MAX</code> used to be part of every surface data. Apparently CLM dropped this variable, but ELM continues to require it. If the reference surface data set is a recent one, this variable will be missing and the surface data file will not work with ELM. To address this, we use <code>T_BUILDING_MIN</code> to re-generate <code>T_BUILDING_MAX</code>, by applying an offset compatible with older surface data files.</p>
<pre class="r"><code>if (! (&quot;T_BUILDING_MAX&quot; %in% names(nc_vars))){
   # Create maximum interior building temperature
   nc_vars$T_BUILDING_MAX = ncvar_def( name     = &quot;T_BUILDING_MAX&quot;
                                     , units    = &quot;K&quot;
                                     , dim      = nc_dims[c(&quot;lsmlon&quot;,&quot;lsmlat&quot;,&quot;numurbl&quot;)]
                                     , missval  = nc_gridin$var$T_BUILDING_MIN$missval
                                     , longname = &quot;maximum interior building temperature&quot;
                                     )#end ncvar_def 

   # Append value to the list of values
   dT_building              = c(15,rep(39,times=nc_dims$numurbl$len-1))
   nc_values$T_BUILDING_MAX = nc_values$T_BUILDING_MIN + dT_building
}# end if (! (&quot;T_BUILDING_MAX&quot; %in% names(nc_vars)))</code></pre>
<p>Create the output files.</p>
<pre class="r"><code># Create output netCDF
nc_surfout = nc_create(filename = output_surfdata,vars=nc_vars)

# Add global attributes
for (a in seq_along(glob_att)){
   # Retrieve attribute information
   a_name  = names(glob_att)[a]
   a_value = glob_att[[a_name]] 

   # Include global attribute      
   dummy = ncatt_put(nc = nc_surfout, varid=0,attname=a_name,attval=a_value)
}#end for (a in seq_along(glob_att))

# Add variables
for (v in seq_along(nc_values)){
   # Retrieve variable information
   v_name  = names(nc_values)[v]
   v_value = nc_values[[v_name]] 

   # Add variable values
   dummy = ncvar_put(nc = nc_surfout,varid=v_name,vals=v_value)
}#end for (v in seq_along(nc_values))

# Close input and output files
dummy = nc_close(nc = nc_gridin )
dummy = nc_close(nc = nc_surfout)</code></pre>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
